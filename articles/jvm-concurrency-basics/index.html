<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="google-site-verification" content="M2S6XRgNZy5AWcjY2MUVhaCDJ8uDRDkHfly4lnaz-lI"><meta name="viewport" content="width=device-width"><title>JVM Concurrency Basics - Tushar Mathur's blog</title><link rel="alternate" href="//feed.xml" type="application/rss+xml" title="A software developer, physics enthusiast, swimmer and a car geek"><link rel="stylesheet" href="/bg.svg" type="image/svg"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,500,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/default.min.css"><link rel="stylesheet" href="/css/main.css" type="text/css"><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-39050808-1']);
_gaq.push(['_trackPageview']);

(function() {
var ga = document.createElement('script');
ga.type = 'text/javascript';
ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(ga, s);
})();

</script></head><body class="article-detail"><header class="header"><div class="top-nav"><div class="red-line"></div><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/archive.html">Archives</a></li><li><a href="/about.html">About Me</a></li></ul></div><div class="content-wrap"><h1>JVM Concurrency Basics</h1><p class="author">by <span class="author"></span>Tushar Mathur</p></div></header><div id="content"><div class="content-wrap"><article class="article"><section class="content"><p>Here are some of my notes on <span class="caps">JVM</span> multithreading and concurrency course on <a href="https://dream11.udemy.com/course/java-multithreading-concurrency-performance-optimizatio">udemy</a> in a Q <span class="amp">&amp;</span> A format. The course is a good start for people who want to write high-performance code on the <span class="caps">JVM</span> and are trying to wrap their heads around the available concurrency<span class="widont">&nbsp;</span>primitives.</p>
<p><em><span class="caps">PS</span>: Feel free to correct and add more details by opening a <span class="caps">PR</span> on <a href="https://github.com/tusharmath/tusharmath.github.io">github</a>.</em></p>
<ul>
<li><a href="#thread-coordination">Thread Coordination</a></li>
<li><a href="#locks-and-race-conditions">Locks and Race<span class="widont">&nbsp;</span>Conditions</a></li>
<li><a href="#data-race">Data Race</a></li>
<li><a href="#thread-interruption">Thread Interruption</a></li>
<li><a href="#synchronization">Synchronization</a></li>
<li><a href="#reentrant-lock">Reentrant Lock</a></li>
<li><a href="#semaphore">Semaphore</a></li>
<li><a href="#condition-variable">Condition Variable</a></li>
<li><a href="#lock-free-concurrency">Lock Free Concurrency</a></li>
</ul>
<h1 id="thread-coordination">Thread Coordination</h1>
<p><strong>What kind of data requires thread coordination on the<span class="widont">&nbsp;</span><span class="caps">JVM</span>?</strong></p>
<p>Anything that is stored on the heap will require coordination between threads. Objects, Class Members, Static Variables are all allocated on the Heap and require thread<span class="widont">&nbsp;</span>coordination.</p>
<p><strong>What kind of data does not require thread<span class="widont">&nbsp;</span>coordination?</strong></p>
<p>Each thread creates it’s own stack and the content of the stack (local variables and references) aren’t shared with other threads and hence don’t require any<span class="widont">&nbsp;</span>coordination.</p>
<h1 id="locks-and-race-conditions">Locks and Race<span class="widont">&nbsp;</span>Conditions</h1>
<p><strong>What is a<span class="widont">&nbsp;</span>deadlock?</strong></p>
<p>When two threads hold on and wait for other to release a common resource, it can cause a deadlock. For eg: Let’s say there are two threads T1, T2 and two resources A, B, the possible condition could<span class="widont">&nbsp;</span>happen</p>
<pre><code class="language-scala"><span class="type">T1</span> -&gt; attemptLock(<span class="type">A</span>) <span class="comment">// Success</span>
<span class="type">T2</span> -&gt; attemptLock(<span class="type">B</span>) <span class="comment">// Success</span>
<span class="type">T1</span> -&gt; attemptLock(<span class="type">B</span>) <span class="comment">// Wait for T2 to release</span>
<span class="type">T2</span> -&gt; attemptLock(<span class="type">A</span>) <span class="comment">// Wait for T1 to release</span></code></pre>
<p>This can trigger a deadlock in the application because T1 is waiting on T2 and T2 is waiting on<span class="widont">&nbsp;</span>T1.</p>
<p><strong>What is a <em>race condition</em><span class="widont">&nbsp;</span>?</strong></p>
<p>A condition where multiple threads are accessing the same resource, and at least one of those threads is modifying the resource and timing of the threads can cause incorrect<span class="widont">&nbsp;</span>results.</p>
<p><strong>What operations are Atomic and don’t require synchronization between threads on the<span class="widont">&nbsp;</span><span class="caps">JVM</span>?</strong></p>
<ol>
<li>All reference assignment are<span class="widont">&nbsp;</span>atomic.</li>
<li>All assignments to primitive types - Int, Short, Byte, Float, Char, Bool <strong>except</strong> for Long and Double. Long and Double are 64 bit long (even on a 64bit computer) it requires <span class="caps">JVM</span> to produce two instructions one to write on each 32<span class="widont">&nbsp;</span>bit.</li>
</ol>
<h1 id="data-race">Data Race</h1>
<p><strong>What is <em>data race</em><span class="widont">&nbsp;</span>?</strong></p>
<p>Sometimes the compiler rearranges instructions internally for better performance viz. branch prediction, parallel execution (<a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data"><span class="caps">SIMD</span></a>), pre-fetching instructions and better cache performance. This can produce a condition where sometimes the final output of the program changes. The condition is observed far more rarely than race<span class="widont">&nbsp;</span>conditions.</p>
<p><strong>What is a <em>volatile</em><span class="widont">&nbsp;</span>variable?</strong></p>
<p>Volatile is used as an annotation to a variable to <strong>make its assignment atomic</strong>. Since most assignments are already atomic, we typically use volatile with Long and Double type<span class="widont">&nbsp;</span>primitives.</p>
<p>Making the variable volatile, ensures that the variable is read from the main memory. This guarantees visibility and ordering when used in a multi threaded<span class="widont">&nbsp;</span>env.</p>
<p><strong>How can I prevent reordering of<span class="widont">&nbsp;</span>instructions?</strong></p>
<p>One can use the <code>volatile</code> keyword in front of the variable to restrict the <span class="caps">JVM</span> from doing any kind of re-ordering<span class="widont">&nbsp;</span>optimisations.</p>
<h1 id="thread-interruption">Thread Interruption</h1>
<p><strong>How can threads be<span class="widont">&nbsp;</span>interrupted?</strong></p>
<p>Threads can be interrupted by calling the <em>interrupt</em> method on the<span class="widont">&nbsp;</span>thread.</p>
<p><strong>What does the <em>interrupt</em> method<span class="widont">&nbsp;</span>do?</strong></p>
<p>Internally it just sets the interrupt flag to true. One can check the status of the flag by calling <code>Thread.interrupted</code></p>
<p><strong>How does <em>interrupt</em> work in<span class="widont">&nbsp;</span>threads?</strong></p>
<p>Calling <code>thread.interrupt</code> internally just sets a flag. It’s up to the implementor to check and act on it. Sometimes, for eg: in <code>Thread.sleep</code> and other implementations will throw an exception <code>InterruptedException</code> when the interrupt flag is<span class="widont">&nbsp;</span>set.</p>
<p><strong>What is a <em>Daemon</em><span class="widont">&nbsp;</span>Thread?</strong></p>
<p>Setting the flag to daemon, means forcefully kill the thread from whatever it’s doing on interrupt. <span class="caps">JVM</span> will not wait for daemon threads to complete before it exits. It will kill them as soon as the main thread is<span class="widont">&nbsp;</span>completed.</p>
<p><strong>Can I call <em>setDaemon</em> after the thread has<span class="widont">&nbsp;</span>started?</strong></p>
<p>No, changing the state of the thread to <em>daemon</em> once started will trigger a <code>IllegalThreadStateException</code> exception.</p>
<p><strong>Can I check in a daemon thread if it’s<span class="widont">&nbsp;</span>interrupted?</strong></p>
<p>No, there is no way to check if the daemon thread was interrupted. The <span class="caps">JVM</span> will immediately kill the<span class="widont">&nbsp;</span>thread.</p>
<h1 id="synchronization">Synchronization</h1>
<p><strong>Why do we pass an object to the <em>synchronize</em><span class="widont">&nbsp;</span>block?</strong></p>
<pre><code class="language-scala"><span class="keyword">val</span> ref = <span class="keyword">new</span> <span class="type">Object</span>()
synchronize (ref) {
   count += count
}</code></pre>
<p>The block that needs to be synchronized, basically needs some context within which it’s synchronized. If two threads are synchronized using the same ref, the two threads will never run that piece of code in parallel. However, if the threads are using two different refs the blocks won’t be<span class="widont">&nbsp;</span>synchronized.</p>
<h1 id="reentrant-lock">Reentrant Lock</h1>
<p><strong>What is a Reentrant<span class="widont">&nbsp;</span>Lock?</strong></p>
<p>Reentrant lock is another alternative to synchronize between threads. It provides more fine grained control over the <code>synchronized</code> method that’s available on<span class="widont">&nbsp;</span>objects.</p>
<p><strong>How is a Reentrant Lock different from the synchronized<span class="widont">&nbsp;</span>block?</strong></p>
<ol>
<li>Reentrant lock needs to be initialized using the <code>new</code> keyword like — <code>new ReentrantLock()</code></li>
<li>It provides additional methods such as <code>getQueuedThreads</code> <code>getOwner</code> <code>isHeldByCurrentThread</code> <code>isLocked</code></li>
<li>Locking and unlocking is done by calling the <code>lock</code> and <code>unlock</code> methods respectively.</li>
</ol>
<p><strong>How can you guarantee fairness in<span class="widont">&nbsp;</span>ReentrantLock?</strong></p>
<p>We can guarantee fairness at the cost of performance by passing <code>true</code> to <code>ReentrantLock</code> eg: <code>new ReentrantLock(true)</code>. This flag ensures that all threads get an equal chance at acquiring a lock on the block of<span class="widont">&nbsp;</span>code.</p>
<p><strong>Can you lock interruptibly using a reentrant<span class="widont">&nbsp;</span>lock?</strong></p>
<p>Yes, it supports <code>lockInterruptibly</code> method which can be interrupted from outside. Using <code>lock</code> directly can block forever sometimes. Locking interruptibly ensures that it can be cancelled by calling interrupt on the<span class="widont">&nbsp;</span>thread.</p>
<p><strong>What is <em>tryLock</em><span class="widont">&nbsp;</span>?</strong></p>
<p><code>tryLock</code> allows a reentrant lock to immediately return with a <code>false</code> if the lock is not acquired. It can also take in a <strong>timeout</strong> incase one doesn’t want to immediately exit if the lock can not be achieved. You can use it as follows<span class="widont">&nbsp;</span>—</p>
<pre><code class="language-scala"><span class="keyword">val</span> lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>()
<span class="comment">// instead of calling `lock` call `tryLock`</span>

lock.tryLock</code></pre>
<p><strong>What is a <em>ReentrantReadWriteLock</em><span class="widont">&nbsp;</span>?</strong></p>
<p>It’s a specialized version of the <code>ReentrantLock</code> that isolates “reads” from “writes”. This gives better performance because multi reads don’t require locks between them. Reads can be done in parallel and it’s only when you are doing a write you would attain a lock on the<span class="widont">&nbsp;</span>object.</p>
<h1 id="semaphore">Semaphore</h1>
<p><strong>What is a<span class="widont">&nbsp;</span>Semaphore?</strong></p>
<p>Semaphores are high level concurrency primitives that are designed to control how many consumers and producers are allowed to access a resource at any given<span class="widont">&nbsp;</span>time.</p>
<p><strong>How is a Semaphore different than a Reentrant<span class="widont">&nbsp;</span>Lock?</strong></p>
<p>Semaphore acquire and release works differently than lock and unlock of ReentrantLock. Semaphores work on permits. The initial number of permits can be passed on to the<span class="widont">&nbsp;</span>constructor.</p>
<p>Each call to acquire reduces the permit by one until each reaches zero. After which further calls to acquire block on the thread until a release is called.
You can call release as many number of times as you want and with each release, the permit count increases.
Also, a release can be called by any thread and not just the thread that called the lock<span class="widont">&nbsp;</span>method.</p>
<h1 id="condition-variable">Condition Variable</h1>
<p><strong>What is a <em>conditionVariable</em><span class="widont">&nbsp;</span>?</strong></p>
<p>ConditionVariables are useful for implementing polling mechanisms on a variable which is updated by multiple threads. You can create a new condition variable on a ReentrantLock by calling <code>newCondition</code> on it.</p>
<pre><code class="language-scala"><span class="keyword">val</span> lock = <span class="keyword">new</span> <span class="type">ReentrantLock</span>()
<span class="keyword">val</span> cond = lock.newCondition()
<span class="keyword">var</span> count = <span class="number">10</span>


<span class="comment">// a thread that waits until the count becomes zero</span>
<span class="keyword">val</span> thread1 = <span class="keyword">new</span> <span class="type">Thread</span>(() =&gt; {


   <span class="keyword">while</span>(<span class="literal">true</span>) {
      lock.lock
      <span class="keyword">if</span> (count == <span class="number">0</span>) {
         println(<span class="string">"Count is zero"</span>)
         lock.unlock
         <span class="literal">true</span>
      } <span class="keyword">else</span> {
         cond.await
      }
   }

})

<span class="comment">// a thread that keeps reducing the count</span>

</code></pre>
<p><strong>How does <em>await</em> work in a condition<span class="widont">&nbsp;</span>variable?</strong></p>
<p>The await method on a condition variable will immediately perform two operations<span class="widont">&nbsp;</span>—</p>
<ol>
<li>Release the acquired lock on the reentrant<span class="widont">&nbsp;</span>variable.</li>
<li>Put the thread in a “wait” state and block it exactly on that<span class="widont">&nbsp;</span>statement.</li>
</ol>
<p>It will only resume once another thread calls <code>signal</code> on the condition variable <span class="caps">AND</span> performs an unlock immediately following<span class="widont">&nbsp;</span>it.</p>
<p>The <code>await</code> statement will not resume unless it’s signaled and it can regain the released<span class="widont">&nbsp;</span>lock.</p>
<p><strong>What happens if you call <em>await</em> without calling <em>lock</em> and<span class="widont">&nbsp;</span>why?</strong></p>
<p>It will result in an invalid state, throwing an exception — <code>IllegalMonitorStateException</code></p>
<p><strong>What happens if you call <em>signal</em> without calling <em>unlock</em> and<span class="widont">&nbsp;</span>why?</strong></p>
<p>Nothing is going to happen. The signal will be sent to the waiting thread however, unless the lock is released, the waiting thread will not continue. Unlock will required to be called after the signal is<span class="widont">&nbsp;</span>sent.</p>
<p><strong>What happens when I call <em>signal</em> after <em>unlock</em><span class="widont">&nbsp;</span>?</strong></p>
<p>It will result in an invalid state, throwing an exception — <code>IllegalMonitorStateException</code>.</p>
<p><strong>How can I use an object as a condition<span class="widont">&nbsp;</span>variable?</strong></p>
<p>Every object supports <code>wait</code> <code>notify</code> and <code>notifyAll</code> methods which are a proxy to the reentrant lock’s condition variables. The <code>lock</code> and <code>unlock</code> doesn’t exist on object, so one needs to use the <code>synchronized</code> block to achieve<span class="widont">&nbsp;</span>that.</p>
<h1 id="lock-free-concurrency">Lock Free Concurrency</h1>
<p><strong>How can one implement lock free<span class="widont">&nbsp;</span>concurrency?</strong></p>
<p>Lock free concurrency can be implemented using the <code>compareAndSet</code> operator that’s available under <code>AtomicReference</code>, <code>AtomicInteger</code> and other Atomic data structures under <code>java.util.concurrent.atomic</code> .</p>
<p>It takes in two parameters viz. <code>expectedValue</code> and <code>newValue</code>. Internally it checks if the internal value is the same as the provided expected value only then should we set it to the newValue. The expected value can be accessed via <code>ref.get</code></p>
<pre><code class="language-scala">compareAndSet(expectedValue, newValue);</code></pre>
</section></article></div></div><footer><div class="content-wrap"><div class="nav"><a href="/">« Full blog</a><a href="https://github.com/tusharmath/tusharmath.github.io/edit/develop/packages/tusharm.com/contents/articles/jvm-concurrency-basics//index.md">Edit »</a></div><div id="disqus_thread"></div><script>/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'tusharmcom'; // required: replace example with your forum shortname
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the<a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com"></a><section class="about"><p>I constantly try to make my everyday tasks simpler and more productive, that’s why I love developing apps for free. Checkout the list of my <a href="/projects.html">projects</a> or click <a href="/about.html">here</a> to know more about me.</p>
<p>In my leisure time I like to learn about physics and cars. I practice swimming and like to be a gourmet from time to time.</p>
<br><div><a class="twitter-follow-button" href="https://twitter.com/tusharmath" data-show-count="false">Follow @tusharmath</a></div><div><iframe src="//ghbtns.com/github-btn.html?user=tusharmath&amp;type=follow" allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe></div></section><section class="copy"><p>&copy; 2026 Tushar Mathur<span> powered by&nbsp;</span><a href="http://wintersmith.io">Wintersmith</a></p></section></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script><script src="/js/analytics.js"></script></body></html>